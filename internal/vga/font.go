package vga

import (
	"image/png"
	"os"
)

var CP437Font [256][8]byte

var defaultFont = [256][8]byte{
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x00, 0xFF},
	{0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00},
	{0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00},
	{0x10, 0x38, 0x7C, 0xFE, 0xFE, 0xFE, 0x00, 0x00},
	{0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00},
	{0xFF, 0xFF, 0x07, 0x0E, 0xFE, 0xC0, 0xF8, 0x00},
	{0x38, 0x7C, 0xFE, 0xFE, 0xC0, 0xF8, 0x78, 0x00},
	{0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00},
	{0x06, 0x0E, 0x7E, 0xFE, 0x7E, 0x0E, 0x06, 0x00},
	{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00},
	{0x06, 0x0E, 0x1E, 0x3E, 0x1E, 0x0E, 0x06, 0x00},
	{0x00, 0x7E, 0x3E, 0x1E, 0x3E, 0x7E, 0x00, 0x00},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18},
	{0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00},
	{0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18, 0x18},
	{0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18},
	{0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00},
	{0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x7E},
	{0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18},
	{0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00},
	{0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00, 0x00},
	{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
	{0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00},
	{0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x00},
	{0x18, 0x18, 0x7E, 0xC3, 0x7E, 0x18, 0x18, 0x00},
	{0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x00, 0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00},
	{0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x0F},
	{0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0xF0},
}

func init() {
	for i := range defaultFont {
		CP437Font[i] = defaultFont[i]
	}
}

func LoadFontFromPNG(path string) error {
	f, err := os.Open(path)
	if err != nil {
		return err
	}
	defer f.Close()

	img, err := png.Decode(f)
	if err != nil {
		return err
	}

	bounds := img.Bounds()
	if bounds.Dx() != 256 || bounds.Dy() != 64 {
		return ErrInvalidFontSize
	}

	for char := 0; char < 256; char++ {
		charX := char % 32
		charY := char / 32
		var bits byte
		for y := 0; y < 8; y++ {
			for x := 0; x < 8; x++ {
				c := img.At(charX*8+x, charY*8+y)
				_, _, _, a := c.RGBA()
				if a > 128 {
					bits |= (1 << uint(x))
				}
			}
			CP437Font[char][y] = bits
		}
	}
	return nil
}

type FontOptions struct {
	Scale       int
	Transparent bool
	BgColor     byte
}

func (fb *Framebuffer) DrawChar(x, y int, ch byte, opts FontOptions) {
	font := CP437Font[ch]
	scale := opts.Scale
	if scale < 1 {
		scale = 1
	}

	for fy := 0; fy < 8; fy++ {
		row := font[fy]
		for fx := 0; fx < 8; fx++ {
			if row&(1<<uint(fx)) != 0 {
				for sy := 0; sy < scale; sy++ {
					for sx := 0; sx < scale; sx++ {
						fb.SetPixel(x+fx*scale+sx, y+fy*scale+sy, 255)
					}
				}
			} else if !opts.Transparent {
				for sy := 0; sy < scale; sy++ {
					for sx := 0; sx < scale; sx++ {
						fb.SetPixel(x+fx*scale+sx, y+fy*scale+sy, opts.BgColor)
					}
				}
			}
		}
	}
}

func (fb *Framebuffer) DrawString(x, y int, s string, opts FontOptions) {
	dx := x
	scale := opts.Scale
	if scale < 1 {
		scale = 1
	}
	for i := range s {
		fb.DrawChar(dx, y, s[i], opts)
		dx += 8 * scale
	}
}

func (fb *Framebuffer) DrawCharBg(x, y int, ch byte, bgColor byte) {
	fb.DrawChar(x, y, ch, FontOptions{Transparent: false, BgColor: bgColor})
}

func (fb *Framebuffer) DrawStringBg(x, y int, s string, bgColor byte) {
	fb.DrawString(x, y, s, FontOptions{Transparent: false, BgColor: bgColor})
}

var ErrInvalidFontSize = &invalidFontSizeError{}

type invalidFontSizeError struct{}

func (e *invalidFontSizeError) Error() string {
	return "font must be 256x64 pixels"
}
